few_shots = [
    {
        'MySQL Query':"SELECT {{USERID}} AS user_id,\n       \"ML_payment_days_since_deliquency\" AS feature, \n       {{PVDATE}} AS epoch_millis,\n       datediff(FROM_UNIXTIME({{PVDATE}}\/1000),deliq_start)\/1 AS value\nFROM        \n(SELECT user_id, \n       min(if(delay > 0, date(payment_date), date(disbursed_at))) as deliq_start\nFROM \n(SELECT p.user_id,\n       user_loan_id,\n       disbursed_at,\n       payment_date,\n       payment_deadline,\n       p.amount,\n       datediff(date(payment_date), date(payment_deadline)) as delay\nFROM payments p\nINNER JOIN user_loan ul ON ul.id = p.user_loan_id\nWHERE p.amount > 10\n  AND p.status <> 'CANCELED'\n  AND p.user_id = {{USERID}}\n  AND unix_timestamp(payment_date)*1000 < {{PVDATE}}) a \n GROUP BY 1) a ",
        'DuckDB Query':"WITH user AS (\n    SELECT {{user_id}} AS user_id\n),\n\ninitial_transform AS (\n    SELECT\n        p.user_id,\n        p.user_loan_id,\n        ul.disbursed_at,\n        p.payment_date,\n        p.payment_deadline,\n        p.amount,\n        TIMESTAMP '1970-01-01 00:00:00' + INTERVAL ({{pv_date}} \/ 1000) SECOND AS pv_date,\n        DATEDIFF('day', CAST(payment_deadline AS DATE), CAST(payment_date AS DATE)) AS delay\n    FROM\n        payments_base__v1 p\n    LEFT JOIN user_loan__v1 ul ON ul.id = p.user_loan_id\n    LEFT JOIN user ON user.user_id = p.user_id\n\n    WHERE\n        p.amount > 10\n        AND p.status <> 'CANCELED'\n        and cast(payment_date as date) <= cast(epoch_ms({{pv_date}}) as date)\n),\n\ndeliq_start AS (\n    SELECT\n        user_id,\n        pv_date,\n        MIN(\n            CASE \n                WHEN delay > 0 THEN CAST(payment_date AS DATE)\n                ELSE CAST(disbursed_at AS DATE)\n            END\n        ) AS deliq_start\n    FROM\n        initial_transform\n    GROUP BY\n        user_id,pv_date\n),\nfeature AS (\n    \n    SELECT\n    user_id,\n     \n    COALESCE(\n            DATEDIFF('day',  cast(deliq_start as date),CAST(pv_date AS DATE)),-99999\n\n    ) AS ML_payment_days_since_deliquency\n    FROM \n    deliq_start\n    \n)\n\nSELECT \n    COALESCE(ML_payment_days_since_deliquency,-99999) AS value\nFROM\n    user u\nLEFT JOIN\n    feature d on d.user_id = u.user_id\n"
    },
    {
        'MySQL Query':"SELECT a.user_id, {{PVDATE}} AS processing_version,\n                           \"ML_payment_max_delayed_days_weighted_avg\" AS feature,\n                            avg(if(b.delay<=0,b.delay,0)) AS value\n\nFROM\n\n(\n    SELECT user_id,\n            user_loan_id\n                \n    FROM user_snapshot\n    WHERE loan_status IN ('DISBURSED','COMPLETED') and user_id = {{USERID}} and unix_timestamp(approved_at)*1000 < {{PVDATE}}\n    group by 1,2\n) a\n            \n            \nLEFT JOIN \n(\n    \n        SELECT s.*,\n                p.status,\n                p.payment_deadline,\n                p.payment_date,\n                p.amount,\n                CASE\n                 WHEN payment_date IS NULL THEN datediff(now(),date(payment_deadline))\n                 ELSE datediff(date(payment_date),date(payment_deadline))\n             END AS delay    \n        FROM\n        (\n            SELECT user_id,\n                    user_loan_id,\n                    approved_at\n            FROM user_snapshot\n            WHERE loan_status IN ('DISBURSED','COMPLETED') and user_id = {{USERID}} and unix_timestamp(approved_at)*1000 < {{PVDATE}}\n        ) s\n        \n        INNER JOIN payments p ON p.user_id=s.user_id\n        AND p.user_loan_id=s.user_loan_id\n        AND p.amount>10 and p.status <> 'CANCELED'\n\n\n) b\non a.user_id = b.user_id \nand a.user_loan_id = b.user_loan_id\ngroup by 1,2,3\n\n\n\n",
        'DuckDB Query':"WITH user AS (\n    SELECT {{user_id}} AS user_id\n)\n,\nt1 AS (\n    SELECT \n        user_id,\n        user_loan_id,\n        approved_at\n    FROM \n        user_snapshot__v1\n    WHERE \n        loan_status IN ('DISBURSED', 'COMPLETED')\n        AND approved_at < epoch_ms({{pv_date}})\n    GROUP BY \n        user_id, user_loan_id,approved_at\n),\nt2 AS (\n    SELECT \n        s.user_id,\n        s.user_loan_id,\n        s.approved_at,\n        p.status,\n        p.payment_deadline,\n        p.payment_date,\n        p.amount,\n        CASE\n            WHEN p.payment_date IS NULL THEN \n                (CAST(NOW() AS DATE) - CAST(p.payment_deadline AS DATE))\n            ELSE \n                (CAST(p.payment_date AS DATE) - CAST(p.payment_deadline AS DATE))\n        END AS delay\n    FROM \n        t1 s\n    INNER JOIN \n        payments_base__v1 p \n        ON p.user_id = s.user_id\n        AND p.user_loan_id = s.user_loan_id\n    WHERE \n        p.amount > 10 \n        AND p.status <> 'CANCELED'\n),\nt3 AS (\n    SELECT \n        a.user_id,\n        AVG(IF(b.delay <= 0, b.delay, 0)) AS value\n    FROM \n        t1 a\n    LEFT JOIN \n        t2 b \n        ON a.user_id = b.user_id \n        AND a.user_loan_id = b.user_loan_id\n    LEFT JOIN user u on a.user_id = u.user_id\n    GROUP BY \n        a.user_id\n)\nSELECT \n    COALESCE(t3.value, -99999) AS value\nFROM \n    t3\nRIGHT JOIN user u on u.user_id = t3.user_id"
    },
    {
        'MySQL Query':"\nSELECT u.user_id,\n       \"ML_payment_first_payment_delayed_days_weighted\" AS feature, {{PVDATE}} AS epoch_millis,\n                                                                             delay\/1  AS value\n                                                                             from\n(select id as user_id from users where id ={{USERID}}) u\nleft  join \n(select a.user_id,a.id as payment_id , \n    CASE\n              WHEN payment_date IS NULL THEN datediff(CURRENT_DATE(),date(payment_deadline))+datediff(CURRENT_DATE(),date(payment_deadline))*amount\/1000\n              ELSE datediff(date(payment_date),date(payment_deadline))+datediff(date(payment_date),date(payment_deadline))*amount\/1000\n          END AS delay from\n     (SELECT *\n           \n         FROM payments\n         WHERE user_id = {{USERID}} AND status <> 'CANCELED' AND amount > 10 AND unix_timestamp(payment_date)*1000<{{PVDATE}}\n      ) a\n      inner join (\n     SELECT user_id, max( user_loan_id) user_loan_id\n             \n         FROM payments\n         WHERE user_id = {{USERID}} AND status <> 'CANCELED' AND amount > 10 AND unix_timestamp(payment_date)*1000<{{PVDATE}}\n      group by 1\n      )x \n      ON x.user_id = a.user_id and x.user_loan_id = a.user_loan_id \n      inner join \n      (\n        SELECT user_id,  user_loan_id,min(id)  payment_id\n            \n         FROM payments\n         WHERE user_id = {{USERID}} AND status <> 'CANCELED' AND amount > 10 AND unix_timestamp(payment_date)*1000<{{PVDATE}}\n         group by 1,2\n      )y ON x.user_loan_id = y.user_loan_id and y.payment_id = a.id) k\n      ON k.user_id = u.user_id",
        'DuckDB Query':"WITH user AS (\n    SELECT\n        {{user_id}} AS user_id\n),\n\nt1 AS (\n    SELECT \n        id AS user_id\n    FROM \n        users__v1\n\n),\n\nt2 AS (\n    SELECT \n        user_id,\n        user_loan_id,\n        id AS payment_id,\n        payment_date,\n        payment_deadline,\n        amount,\n        CASE\n            WHEN payment_date IS NULL THEN \n                DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(CURRENT_DATE AS DATE)) + \n                DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(CURRENT_DATE AS DATE)) * amount \/ 1000\n            ELSE \n                DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(payment_date AS DATE)) + \n                DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(payment_date AS DATE)) * amount \/ 1000\n        END AS delay\n    FROM \n        payments_base__v1\n    WHERE \n        status <> 'CANCELED'\n        AND amount > 10\n        AND payment_date < epoch_ms({{pv_date}}) \n),\n\nt3 AS (\n    SELECT \n        user_id,\n        MAX(user_loan_id) AS user_loan_id\n    FROM \n        t2\n    GROUP BY \n        user_id\n),\n\nt4 AS (\n    SELECT \n        user_id,\n        user_loan_id,\n        MIN(payment_id) AS payment_id\n    FROM \n        t2\n    GROUP BY \n        user_id, user_loan_id\n),\n\njoined AS (\n    SELECT \n        t2.user_id,\n        t2.delay\n    FROM \n        t2\n    INNER JOIN \n        t3 \n        ON t2.user_id = t3.user_id \n        AND t2.user_loan_id = t3.user_loan_id\n    INNER JOIN \n        t4 \n        ON t3.user_loan_id = t4.user_loan_id \n        AND t4.payment_id = t2.payment_id\n)\n\nSELECT \n    \n    COALESCE(joined.delay, -99999) AS ML_payment_first_payment_delayed_days_weighted\nFROM \n    t1\nLEFT JOIN \n    joined \nON \n    t1.user_id = joined.user_id\nRIGHT JOIN user on user.user_id = t1.user_id"
    },
    {
        'MySQL Query':"SELECT {{USERID}} AS user_id,\n                \"ML_payment_last_payment_delayed_days_weighted\" AS feature, {{PVDATE}} AS epoch_millis,\n                                                                               delay\/1 AS value\nFROM\n(SELECT {{USERID}} AS user_id) t\nleft join \n  (SELECT a.user_id,\n          a.user_loan_id,\n       max(delay) delay\n   FROM\n     (SELECT user_id, user_loan_id, id payment_id,datediff(date(payment_date),date(payment_deadline))*amount\/1000+datediff(date(payment_date),date(payment_deadline)),\n       CASE\n       WHEN payment_date IS  NULL THEN datediff(date(now()),date(payment_deadline))+datediff(date(now()),date(payment_deadline))*amount\/1000\n                 ELSE datediff(date(payment_date),date(payment_deadline))*amount\/1000+datediff(date(payment_date),date(payment_deadline))\n             END AS delay\n          FROM payments\n           WHERE user_id = {{USERID}} AND status <> 'CANCELED' and amount > 10   AND unix_timestamp(payment_date)*1000 < {{PVDATE}}\n     ) a\n inner join\n( select user_id,max(user_loan_id) max_loan_id\n         from payments \n         where user_id = {{USERID}} and status <> 'CANCELED' and amount > 10  and unix_timestamp(payment_date)*1000 < {{PVDATE}}\n        group by 1) c ON a.user_id = c.user_id and c.max_loan_id= a.user_loan_id\n inner join\n     (select user_id,user_loan_id,max(id) ml_id \n         from payments \n         where user_id = {{USERID}} and status <> 'CANCELED' and amount > 10  and unix_timestamp(payment_date)*1000 < {{PVDATE}}\n        group by 1,2 ) b on a.user_id = b.user_id and a.payment_id = b.ml_id and b.user_loan_id = c.max_loan_id\n\n   GROUP BY 1,2)b ON b.user_id = t.user_id ",
        'DuckDB Query':"WITH base_data AS (\n    SELECT \n        user_id,\n        user_loan_id,\n        id AS payment_id,\n        CAST(payment_date AS DATE) AS payment_date,\n        CAST(payment_deadline AS DATE) AS payment_deadline,\n        amount,\n        DATEDIFF('day', CAST(payment_deadline AS DATE), CAST(payment_date AS DATE)) * amount \/ 1000\n        + DATEDIFF('day', CAST(payment_deadline AS DATE), CAST(payment_date AS DATE)) AS delay,\n        CASE\n            WHEN payment_date IS NULL THEN \n                DATEDIFF('day', CAST(payment_deadline AS DATE), CAST(current_date AS DATE))\n                + DATEDIFF('day', CAST(payment_deadline AS DATE), CAST(current_date AS DATE)) * amount \/ 1000\n            ELSE \n                DATEDIFF('day', CAST(payment_deadline AS DATE), CAST(payment_date AS DATE)) \n                * amount \/ 1000 \n                + DATEDIFF('day', CAST(payment_deadline AS DATE), CAST(payment_date AS DATE))\n        END AS calculated_delay\n    FROM payments_base__v1\n    WHERE status <> 'CANCELED'\n      AND amount > 10\n      AND payment_date < epoch_ms({{pv_date}}) -- convert epoch_ms to date\n),\n\nmax_loan AS (\n    SELECT \n        user_id,\n        MAX(user_loan_id) AS max_loan_id\n    FROM base_data\n    GROUP BY user_id\n),\nuser as (\n    SELECT {{user_id}} as user_id\n),\nmax_payment AS (\n    SELECT \n        user_id,\n        user_loan_id,\n        MAX(payment_id) AS ml_id\n    FROM base_data\n    GROUP BY user_id, user_loan_id\n),\n\ndelay_data AS (\n    SELECT \n        b.user_id,\n        b.user_loan_id,\n        MAX(b.calculated_delay) AS delay\n    FROM base_data b\n    INNER JOIN max_loan c ON b.user_id = c.user_id AND b.user_loan_id = c.max_loan_id\n    INNER JOIN max_payment d ON b.user_id = d.user_id AND b.payment_id = d.ml_id AND b.user_loan_id = d.user_loan_id\n    GROUP BY b.user_id, b.user_loan_id\n)\n\nSELECT \n    COALESCE(dd.delay, -99999) AS value\nFROM delay_data dd\nRight JOIN  user u ON dd.user_id = u.user_id\n"
    },
    {
        'MySQL Query':"SELECT x.user_id,\n       x.pv AS processing_version,\n       'ML_payment_loan_index' AS feature,\n       max(z.loan_index) AS value\nFROM \n (SELECT {{USERID}} as user_id,{{PVDATE}} as pv) x\nLEFT JOIN \n(select base.user_id, base.pv, y.loan_index as loan_index\nfrom \n    (SELECT {{USERID}} as user_id,{{PVDATE}} as pv) AS base\nINNER JOIN user_loan_metadata y ON base.user_id = y.user_id and \nunix_timestamp(y.created_at)*1000 <= {{PVDATE}}) as z \n    ON x.user_id = z.user_id\n      GROUP BY 1,\n               2,\n               3",
        'DuckDB Query':"WITH user AS (\n    SELECT {{user_id}} as user_id\n)\n,t1 AS (\n    SELECT\n        user_id,\n        loan_index as loan_index,\n        TIMESTAMP '1970-01-01 00:00:00' + INTERVAL ({{pv_date}} \/ 1000) SECOND AS pv_date,\n        created_at\n    FROM\n        user_loan_metadata__v1\n    \n)\n\nSELECT\n   \n    COALESCE( MAX(loan_index) , -99999) AS value\nFROM\n    t1\nRIGHT JOIN user u ON\n    t1.user_id = u.user_id \nWHERE\n    created_at < pv_date\n"
    },
    {
        'MySQL Query':"SELECT {{USERID}} AS user_id,\n                'ML_payment_avg_delayed_days_inverse_weighted_till_last_loan' AS feature, {{PVDATE}} AS epoch_millis,\n                                                                                                   value\nFROM\n  (SELECT a.user_id,\n          avg(if(delay>0,delay,0)) AS value\n   FROM\n     (SELECT user_id,\n             id payment_id,\n             user_loan_id,\n             datediff(date(payment_date),date(payment_deadline))+datediff(date(payment_date),date(payment_deadline))*amount\/1000*{{WEIGHT}}+datediff(date(payment_date),date(payment_deadline))*1000\/amount*{{INVWEIGHT}} AS delay\n      FROM payments\n      WHERE user_id = {{USERID}}\n        AND status <> 'CANCELED'\n        AND amount > 10\n        AND unix_timestamp(payment_date)*1000<{{PVDATE}} ) a\n   GROUP BY 1) c",
        'DuckDB Query':"WITH user AS (\n    SELECT {{user_id}} AS user_id\n),\n\nt1 AS (\n    SELECT \n        user_id,\n        user_loan_id,\n        DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(payment_date AS DATE)) + \n        DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(payment_date AS DATE)) * amount \/ 1000 * 1 +\n        DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(payment_date AS DATE))* 1000 \/ amount * 0 AS delay\n    FROM \n        payments_base__v1\n    WHERE \n        status <> 'CANCELED'\n        AND amount > 10\n        AND CAST(payment_date AS DATE) < CAST(epoch_ms({{pv_date}}) AS DATE)\n),\n\nt2 AS (\n    SELECT \n        user_id,\n        -- Calculate average delay where delay is positive, otherwise 0\n        AVG(CASE WHEN delay > 0 THEN delay ELSE 0 END) AS value\n    FROM \n        t1\n    GROUP BY \n        user_id\n)\n\nSELECT \n    COALESCE(t2.value, -99999) AS value\nFROM \n    user\nLEFT JOIN \n    t2 ON user.user_id = t2.user_id\n"
    },
    {
        'MySQL Query':"SELECT {{USERID}} AS user_id,\n                \"ML_payment_max_delay_completed_payments_till_last_loan\" AS feature, {{PVDATE}} AS epoch_millis,\n                                                                               max_delay\/1 AS value\nFROM\n  (SELECT a.user_id,\n          max(delay) AS max_delay\n   FROM\n     (SELECT user_id, user_loan_id, id payment_id, datediff(date(payment_date),date(payment_deadline)) delay\n      FROM payments a  \n        WHERE user_id = {{USERID}}\n        AND status <> 'CANCELED' AND amount > 10 AND unix_timestamp(payment_date)*1000 < {{PVDATE}}\n        ) a\n   GROUP BY 1)b",
        'DuckDB Query':"WITH user as (\nSELECT {{user_id}} as user_id),\n\nt1 AS (\n    SELECT \n        u.user_id,\n        user_loan_id,\n        COALESCE(CAST(payment_date AS DATE) - CAST(payment_deadline AS DATE),0) AS delay\n    FROM \n         user u\n    LEFT JOIN\n        payments_base__v1 p ON\n        u.user_id = p.user_id\n    \n    WHERE \n         status <> 'CANCELED'\n        AND amount > 10\n        AND payment_date <  epoch_ms({{pv_date}})\n    \n),\n\nt2 AS (\n    SELECT\n        user_id,\n        MAX(delay) AS max_delay\n    FROM \n        t1\n    GROUP BY \n        user_id\n)\nSELECT \n    COALESCE(t2.max_delay, -99999) AS value\nFROM \n    user\nLEFT JOIN t2 on user.user_id = t2.user_id\n"
    },
    {
        'MySQL Query':"SELECT {{USERID}} AS user_id,\n        'ML_payment_max_delayed_days_weighted_till_last_loan' AS feature,\n        {{PVDATE}} AS epoch_millis,\n        value\nFROM\n  (SELECT a.user_id,\n          max(delay)\/1 AS value\n   FROM\n     (SELECT user_id, id payment_id,  user_loan_id,\n             datediff(date(payment_date),date(payment_deadline))+datediff(date(payment_date),date(payment_deadline))*amount\/1000*{{WEIGHT}}+datediff(date(payment_date),date(payment_deadline))*1000\/amount*{{INVWEIGHT}} AS delay\n         FROM payments\n         WHERE user_id = {{USERID}} AND status <> 'CANCELED' AND amount > 10 AND unix_timestamp(payment_date)*1000<{{PVDATE}}\n      ) a\n   GROUP BY 1 ) c",
        'DuckDB Query':"WITH user AS (\n    SELECT\n        {{user_id}} AS user_id\n),\nt1 AS (\n    SELECT \n        user_id,\n        TIMESTAMP '1970-01-01 00:00:00' + INTERVAL ({{pv_date}} \/ 1000) SECOND AS pv_date,\n        \n        user_loan_id,\n        DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(payment_date AS DATE)) + \n        DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(payment_date AS DATE)) * amount \/ 1000 * 1 +\n        DATEDIFF('DAY',CAST(payment_deadline AS DATE),CAST(payment_date AS DATE))* 1000 \/ amount * 0 AS delay\n    FROM \n        payments_base__v1\n    WHERE \n        status <> 'CANCELED'\n        AND amount > 10\n        AND CAST(payment_date AS DATE) <  CAST(pv_date AS DATE)\n),\nt2 AS (\n    SELECT \n        user_id,\n        MAX(delay) AS value\n    FROM \n        t1\n    GROUP BY \n        user_id\n)\nSELECT \n    \n    COALESCE(t2.value, -99999) AS ML_payment_max_delayed_days_weighted_till_last_loan\nFROM \n    t2\nRIGHT JOIN user on user.user_id = t2.user_id\n"
    },
    {
        'MySQL Query':"SELECT {{USERID}} user_id, {{PVDATE}} AS processing_version,\n                           \"ML_payment_avg_early_days_inverse_weighted\" AS feature,\n                            (t.avg_delay ) AS value\nFROM\n  (SELECT user_id,\n          max(approved_at) approved_at,\n          max(user_loan_id) user_loan_id\n   FROM user_snapshot\n   WHERE loan_status IN ('DISBURSED',\n                         'COMPLETED') and user_id = {{USERID}} and unix_timestamp(approved_at)*1000 < {{PVDATE}} group by 1) a\ninner join  \n  ((SELECT t.user_id,\n          t.user_loan_id,\n          t.approved_at,\n          avg(if(t.delay<=0,t.delay,0)) avg_delay\n   FROM\n     (SELECT s.*,\n             p.status,\n             p.payment_deadline,\n             p.payment_date,\n             p.amount,\n             CASE\n                 WHEN payment_date IS NULL THEN datediff(CURRENT_DATE(),date(payment_deadline))+datediff(CURRENT_DATE(),date(payment_deadline))*1000\/amount\n                 ELSE datediff(date(payment_date),date(payment_deadline))+datediff(date(payment_date),date(payment_deadline))*1000\/amount\n             END AS delay\n      FROM\n        (SELECT user_id,\n                user_loan_id,\n                approved_at\n         FROM user_snapshot\n         WHERE loan_status IN ('COMPLETED') and user_id  = {{USERID}}) s\n      INNER JOIN payments p ON p.user_id=s.user_id\n      AND p.user_loan_id=s.user_loan_id\n      AND p.amount>10 and p.status <> 'CANCELED') t\n   GROUP BY 1,\n            2,\n            3)) t\n\n     ON t.user_loan_id = a.user_loan_id and unix_timestamp(t.approved_at)*1000 < {{PVDATE}}\nGROUP BY 1",
        'DuckDB Query':"WITH user AS (\n    SELECT\n        {{user_id}} AS user_id\n),\nt1 AS (\n    SELECT \n        *\n    FROM \n        user_snapshot__v1\n    WHERE \n        loan_status IN ('COMPLETED')\n),\nt2 AS (\n    SELECT \n        s.*,\n        p.status,\n        p.payment_deadline,\n        p.payment_date,\n        p.amount,\n        CASE\n            WHEN payment_date IS NULL THEN \n                (CAST(CURRENT_DATE AS DATE) - CAST(payment_deadline AS DATE)) + \n                ((CAST(CURRENT_DATE AS DATE) - CAST(payment_deadline AS DATE)) * 1000 \/ p.amount)\n            ELSE \n                (CAST(payment_date AS DATE) - CAST(payment_deadline AS DATE)) + \n                ((CAST(payment_date AS DATE) - CAST(payment_deadline AS DATE)) * 1000 \/ p.amount)\n        END AS delay\n    FROM \n        t1 s\n    INNER JOIN \n        payments_base__v1 p \n        ON p.user_id = s.user_id\n        AND p.user_loan_id = s.user_loan_id\n    WHERE \n        p.amount > 10 \n        AND p.status <> 'CANCELED'\n),\n\nt3 AS (\n    SELECT \n        user_id,\n        MAX(approved_at) AS approved_at,\n        MAX(user_loan_id) AS user_loan_id\n    FROM \n        t1\n    WHERE \n        loan_status IN ('DISBURSED', 'COMPLETED') \n        AND cast(approved_at as DATE) < CAST(epoch_ms({{pv_date}}) AS DATE)\n    GROUP BY \n        user_id\n),\nt4 as (\nSELECT \n    a.user_id,\n    AVG(IF(delay <= 0, delay, 0)) AS ML_payment_avg_early_days_inverse_weighted\nFROM \n    t2 t\nINNER JOIN \n        t3 a \nON t.user_loan_id = a.user_loan_id\nGROUP BY 1\n)\nSELECT\n    COALESCE(ML_payment_avg_early_days_inverse_weighted, -99999) AS value\nFROM\n    t4 t\nRIGHT JOIN user u ON t.user_id = u.user_id\n\n    \n    "
    },
    {
        'MySQL Query':"select\nuser_id\n,epoch_millis\n,'RIPPLE_TENURE_3to4_4to5_TIE_BREAKER' as feature\n,case when (retro_flag = 1 and date(retro_flag_date_check) <= date('2024-07-03')) then 3\n      when ab_key < 10 then 1 else 2 end as value\nfrom \n(\n    select\n    base.user_id\n    ,base.epoch_millis\n    ,coalesce(a.retro_flag,0) as retro_flag\n    ,coalesce(date(max_ul_updated_at),current_date) as retro_flag_date_check\n    ,mod((base.user_id*concat(substring(u_ct,6,1),substring(u_ct,8,1))*1.0),100) as ab_key\n    from \n    (\n        select \n        {{USERID}} as user_id\n        ,{{PVDATE}} as epoch_millis\n    ) base\n    left join \n    (\n        select \n        id\n        ,max(unix_timestamp(u.created_at)) as u_ct\n        from \n        users u\n        where 1=1\n              and id = {{USERID}}\n    ) u on u.id = base.user_id\n    left join \n    (\n        select \n        ul.user_id\n        ,1 as retro_flag\n        ,max(ul.updated_at) as max_ul_updated_at\n        from \n        user_loan ul\n        inner join user_category_condition_results uccr on uccr.user_loan_id = ul.id\n        where 1=1\n              and ul.user_id = {{USERID}}\n              and ul.status = 'APPROVED'\n              and uccr.categories like ('%RIPPLE%')\n        group by 1,2      \n    ) a on a.user_id = base.user_id\n) b\n",
        'DuckDB Query':"\nWITH base_data AS (\n    SELECT \n        {{user_id}} AS user_id,\n        {{pv_date}} AS epoch_millis\n),\nuser_info AS (\n    SELECT \n        id,\n        CAST(MAX(EXTRACT(EPOCH FROM created_at)) AS BIGINT) AS u_ct\n    FROM \n        users__v1 u\n\n    GROUP BY \n        id\n),\nuser_loan_data AS (\n    SELECT \n        ul.user_id,\n        1 AS retro_flag,\n        MAX(ul.updated_at) AS max_ul_updated_at\n    FROM \n        user_loan__v1 ul\n    INNER JOIN \n        user_category_condition_results__v1 uccr ON uccr.user_loan_id = ul.id\n    WHERE \n\n        ul.status = 'APPROVED' AND\n        uccr.categories LIKE '%RIPPLE%'\n    GROUP BY \n        ul.user_id, retro_flag\n),\nfinal_data AS (\n    SELECT\n        base.user_id,\n        base.epoch_millis,\n        COALESCE(a.retro_flag, 0) AS retro_flag,\n        COALESCE(CAST(a.max_ul_updated_at AS DATE), CURRENT_DATE) AS retro_flag_date_check,\n        MOD((base.user_id * CAST(CONCAT(SUBSTRING(CAST(u.u_ct AS VARCHAR), 6, 1), SUBSTRING(CAST(u.u_ct AS VARCHAR), 8, 1)) AS INTEGER)) * 1.0, 100) AS ab_key\n    FROM \n        base_data base\n    LEFT JOIN \n        user_info u ON u.id = base.user_id\n    LEFT JOIN \n        user_loan_data a ON a.user_id = base.user_id\n)\nSELECT\n    CASE \n        WHEN (retro_flag = 1 AND retro_flag_date_check <= CAST('2024-07-03' AS DATE)) THEN 3\n        WHEN ab_key < 10 THEN 1 \n        ELSE 2 \n    END AS value\nFROM final_data\n\n"
    },
    {
        'MySQL Query':"select \nuser_id\n,epoch_millis\n,'VIFO_TIE_BREAKER_v2' as feature\n,case when ab_user_id is not null then 3\n      else (case when mod(user_id,100) < 99 then 1 else 2 end) end as value\nfrom \n(\n    select\n    base.user_id\n    ,base.epoch_millis\n    ,ab.user_id as ab_user_id\n    from \n    (\n        select \n        {{USERID}} as user_id\n        ,{{PVDATE}} as epoch_millis\n    ) base\n    left join user_ab_group ab on ab.user_id = base.user_id and ab.test_id = 255 and bucket_id = 1\n) fin",
        'DuckDB Query':"WITH user_data AS (\n    SELECT \n        {{user_id}} AS user_id,\n        {{pv_date}} AS epoch_millis\n),\nab_data AS (\n    SELECT \n        base.user_id,\n        base.epoch_millis,\n        ab.user_id AS ab_user_id\n    FROM \n        user_data base\n    LEFT JOIN \n        user_ab_group__v1 ab ON ab.user_id = base.user_id AND ab.test_id = 255 AND bucket_id = 1\n),\nt1 as (\nSELECT \n    user_id,\n    CASE \n        WHEN ab_user_id IS NOT NULL THEN 3\n        ELSE (CASE WHEN user_id % 100 < 99 THEN 1 ELSE 2 END) \n    END AS value\nFROM \n    ab_data)\nSELECT \n    COALESCE(value,-99999)\nFROM T1\nRIGHT JOIN user_data on T1.user_id = user_data.user_id\n"
    },

    {
        'MySQL Query':"select\nuser_id\n,epoch_millis\n,case when sms.total_months_data >= 3 and sms.total_consecutives >= 2 and sms.median_income >= 10000 then round(sms.median_income,0) else 0 end as kw_sms_consec_income\n,coalesce(sms.median_income,0) as kw_income\n,0 as value\nfrom \n(\n    select\n    user_id\n    ,epoch_millis\n    ,total_months_data\n    ,sum(case when sms_prev_salary_date is null then 0\n              when datediff(sms_salary_date,sms_prev_salary_date) <= 31 and sms_monthly_income > 0 and sms_prev_monthly_income > 0 and ((abs(sms_monthly_income - sms_prev_monthly_income) <= 20000) or ((sms_monthly_income\/sms_prev_monthly_income) between 0.7 and 1.3)) then 1 \n              else 0 end) as total_consecutives\n    ,avg(case when mod(total_months_data,2) = 1 then (case when (total_months_data+1)\/2.0 = income_rnk then sms_monthly_income else null end)\n              else (case when total_months_data\/2.0 = income_rnk then sms_monthly_income\n                        when (total_months_data\/2.0)+1 = income_rnk then sms_monthly_income\n                        else null end) end) as median_income\n    from \n    (\n        select \n        *\n        from \n        (\n            select \n            {{USERID}} as user_id\n            ,{{PVDATE}} as epoch_millis\n        ) base\n        left join \n        (\n            select\n            a.user_id as sms_user_id\n            ,a.salary_date as sms_salary_date\n            ,prev.prev_salary_date as sms_prev_salary_date\n            ,a.monthly_income as sms_monthly_income\n            ,prev.prev_monthly_income as sms_prev_monthly_income\n            from \n            (\n                select\n                user_id\n                ,date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')) as salary_date\n                ,monthly_income\n                ,case when right(yr_month,2) = 1 then 12\n                      else right(yr_month,2) -1 end as prev_month\n                ,case when right(yr_month,2) = 1 then left(yr_month,4)-1\n                      else left(yr_month,4) end as prev_year\n                from \n                (\n                    select \n                    id ,user_id ,yr_month ,monthly_income \n                    from \n                    user_income\n                    where 1=1\n                          and user_id = {{USERID}}\n                          and source = 'SMS_KEYWORD_INCOME'\n                          and type = 'AUTO'\n                          and deleted = 0\n                          and monthly_income > 0\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 <= {{PVDATE}}\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 >= {{PVDATE}} - (184*24*3600*1000)\n                ) b\n            ) a\n            left join \n            (\n                select\n                user_id\n                ,date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')) as prev_salary_date\n                ,left(yr_month,4) as prev_year\n                ,right(yr_month,2) as prev_month\n                ,monthly_income as prev_monthly_income\n                from \n                (\n                    select \n                    id ,user_id ,yr_month ,monthly_income \n                    from \n                    user_income\n                    where 1=1\n                          and user_id = {{USERID}}\n                          and source = 'SMS_KEYWORD_INCOME'\n                          and type = 'AUTO'\n                          and deleted = 0\n                          and monthly_income > 0\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 <= {{PVDATE}}\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 >= {{PVDATE}} - (184*24*3600*1000)) b\n            ) prev on a.user_id = prev.user_id and a.prev_month = prev.prev_month and a.prev_year = prev.prev_year\n        ) sms on sms.sms_user_id = base.user_id\n        left join \n        (\n            select\n            m.user_id as m_user_id\n            ,count(distinct salary_date) as total_months_data\n            from \n            (\n                select\n                user_id\n                ,date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')) as salary_date\n                ,monthly_income\n                ,case when right(yr_month,2) = 1 then 12\n                      else right(yr_month,2) -1 end as prev_month\n                ,case when right(yr_month,2) = 1 then left(yr_month,4)-1\n                      else left(yr_month,4) end as prev_year\n                from \n                (\n                    select \n                    id ,user_id ,yr_month ,monthly_income \n                    from \n                    user_income\n                    where 1=1\n                          and user_id = {{USERID}}\n                          and source = 'SMS_KEYWORD_INCOME'\n                          and type = 'AUTO'\n                          and deleted = 0\n                          and monthly_income > 0\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 <= {{PVDATE}}\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 >= {{PVDATE}} - (184*24*3600*1000)\n                ) b\n            ) m\n            group by 1\n        ) m on m.m_user_id = base.user_id\n        left join\n        (\n            select\n            a.user_id as rnk_user_id\n            ,a.salary_date as rnk_salary_date\n            ,a.monthly_income as rnk_monthly_income\n            ,count(*) as income_rnk\n            from\n            (\n                select \n                user_id\n                ,date(concat(left(t1.yr_month,4),'-',right(t1.yr_month,2),'-','01')) as salary_date\n                ,monthly_income\n                from \n                (\n                    select \n                    id ,user_id ,yr_month ,monthly_income \n                    from \n                    user_income\n                    where 1=1\n                          and user_id = {{USERID}}\n                          and source = 'SMS_KEYWORD_INCOME'\n                          and type = 'AUTO'\n                          and deleted = 0\n                          and monthly_income > 0\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 <= {{PVDATE}}\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 >= {{PVDATE}} - (184*24*3600*1000)\n                ) t1\n            ) a\n            left join\n            (\n                select \n                user_id\n                ,date(concat(left(t1.yr_month,4),'-',right(t1.yr_month,2),'-','01')) as salary_date\n                ,monthly_income\n                from \n                (\n                    select \n                    id ,user_id ,yr_month ,monthly_income \n                    from \n                    user_income\n                    where 1=1\n                          and user_id = {{USERID}}\n                          and source = 'SMS_KEYWORD_INCOME'\n                          and type = 'AUTO'\n                          and deleted = 0\n                          and monthly_income > 0\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 <= {{PVDATE}}\n                              and unix_timestamp(date(concat(left(yr_month,4),'-',right(yr_month,2),'-','01')))*1000 >= {{PVDATE}} - (184*24*3600*1000)\n                ) t1\n            ) b on 1=1\n                   and a.user_id = b.user_id\n                   and ((b.monthly_income < a.monthly_income)\n                         or (a.monthly_income = b.monthly_income and b.salary_date <= a.salary_date))\n        group by 1,2,3                 \n        ) rnk on rnk.rnk_user_id = sms.sms_user_id and rnk.rnk_salary_date = sms.sms_salary_date\n    ) fin\n    group by 1,2,3\n) sms      ",
        'DuckDB Query':"WITH common_data AS (\n    SELECT\n        ui.user_id,\n        CAST(CONCAT(LEFT(yr_month, 4), '-', RIGHT(yr_month, 2), '-01') AS DATE) AS salary_date,\n        ui.monthly_income,\n        LAG(CAST(CONCAT(LEFT(yr_month, 4), '-', RIGHT(yr_month, 2), '-01') AS DATE)) \n            OVER (PARTITION BY ui.user_id ORDER BY salary_date) AS prev_salary_date,\n        LAG(monthly_income) \n            OVER (PARTITION BY ui.user_id ORDER BY salary_date) AS prev_monthly_income\n    FROM \n        user_income__v1 ui\n    WHERE \n        source = 'SMS_KEYWORD_INCOME'\n        AND type = 'AUTO'\n        AND deleted = 0\n        AND monthly_income > 0\n        AND extract(epoch from CAST(concat(left(yr_month, 4), '-', right(yr_month, 2), '-01') AS DATE)) * 1000 <= {{pv_date}}\nAND CAST(CONCAT(LEFT(yr_month, 4), '-', RIGHT(yr_month, 2), '-01') AS DATE) >= CAST(epoch_ms({{pv_date}}) AS DATE) - 184),\nbase AS (\n    SELECT \n        {{user_id}} AS user_id,\n        {{pv_date}} AS epoch_millis\n),\ntotal_months_data AS (\n    SELECT \n        user_id,\n        COUNT(DISTINCT salary_date) AS total_months_data\n    FROM \n        common_data\n    GROUP BY user_id\n),\nconsecutive_months AS (\n    SELECT \n        user_id,\n        SUM(\n            CASE \n                WHEN prev_salary_date IS NULL THEN 0\n                WHEN datediff('day', salary_date, prev_salary_date) <= 31 \n                     AND monthly_income > 0 \n                     AND prev_monthly_income > 0\n                     AND (\n                         ABS(monthly_income - prev_monthly_income) <= 20000 \n                         OR (monthly_income \/ prev_monthly_income BETWEEN 0.7 AND 1.3)\n                     ) \n                THEN 1\n                ELSE 0 \n            END\n        ) AS total_consecutives\n    FROM \n        common_data\n    GROUP BY user_id\n),\nincome_ranking AS (\n    SELECT \n        a.user_id,\n        a.salary_date,\n        a.monthly_income,\n        COUNT(*) OVER (PARTITION BY a.user_id ORDER BY a.salary_date) AS income_rnk\n    FROM \n        common_data a\n    LEFT JOIN common_data b ON a.user_id = b.user_id\n       AND (b.monthly_income < a.monthly_income \n            OR (a.monthly_income = b.monthly_income AND b.salary_date <= a.salary_date))\n),\nmedian_income AS (\n    SELECT \n        user_id,\n        AVG(\n            CASE \n                WHEN mod(total_months_data, 2) = 1 THEN \n                    CASE WHEN (total_months_data + 1) \/ 2.0 = income_rnk THEN monthly_income ELSE NULL END\n                ELSE \n                    CASE \n                        WHEN total_months_data \/ 2.0 = income_rnk THEN monthly_income\n                        WHEN (total_months_data \/ 2.0) + 1 = income_rnk THEN monthly_income\n                        ELSE NULL \n                    END \n            END\n        ) AS median_income\n    FROM \n        income_ranking\n    JOIN total_months_data USING(user_id)\n    GROUP BY user_id\n)\nSELECT \n   \n    CASE \n        WHEN tmd.total_months_data >= 3 \n             AND cm.total_consecutives >= 2 \n             AND mi.median_income >= 10000 \n        THEN ROUND(mi.median_income, 0)\n        ELSE 0 \n    END AS kw_sms_consec_income,\n    COALESCE(mi.median_income, 0) AS kw_income,\n    0 AS value\nFROM \n    base\nLEFT JOIN total_months_data tmd ON base.user_id = tmd.user_id\nLEFT JOIN consecutive_months cm ON base.user_id = cm.user_id\nLEFT JOIN median_income mi ON base.user_id = mi.user_id"
    },
    {
        'MySQL Query':"select\nbase.*\n,'RIPPLE_STD_EAF1' as feature\n,case when ab.bucket_id is null then 1.0\n      when ab.bucket_id = 0 then 1.0\n      when ab.bucket_id = 1 then 1.2\n      when ab.bucket_id = 2 then 0.8\n      else 1 end as value\nfrom \n(\n    select \n    {{USERID}} as user_id\n    ,{{PVDATE}} as epoch_millis\n) base\nleft join user_ab_group ab on ab.user_id = base.user_id and ab.test_id = 420",
        'DuckDB Query':"WITH Base AS (\n    SELECT \n        {{user_id}} AS user_id, \n        {{pv_date}} AS epoch_millis\n),\n\nABGroup AS (\n    SELECT \n        ab.user_id, \n        ab.bucket_id\n    FROM \n        user_ab_group__v1 ab\n    WHERE \n        ab.test_id = 420\n)\n\nSELECT \n\n    CASE \n        WHEN ab.bucket_id IS NULL THEN 1.0\n        WHEN ab.bucket_id = 0 THEN 1.0\n        WHEN ab.bucket_id = 1 THEN 1.2\n        WHEN ab.bucket_id = 2 THEN 0.8\n        ELSE 1 \n    END AS value\nFROM \n    Base base\nLEFT JOIN \n    ABGroup ab \nON \n    ab.user_id = base.user_id\n"
    },
    {
        'MySQL Query':"select \nsc.user_id\n,sc.epoch_millis\n,'CIBIL_SCORE_BELOW_THRESHOLD' as feature\n,coalesce(cv.cibil_metadata_id, -9999) as cibil_metadata_id\n,coalesce(cv.cibil_report_id, -9999) as cibil_report_id\n,coalesce(cv.cibil_score, -9999) as cibil_score\n,case when cibil_score is null then -9999\n      when latest_completed_loan_id is not null then (case when cibil_score >=300 and cibil_score < 620 then 1 else 0 end)\n      when latest_completed_loan_id is null then (case when cibil_score >=300 and cibil_score < 680 then 1 else 0 end)\n      else 0 end as value\n\nfrom \n(\n    select\n    sc.*\n    ,max(ul.id) as latest_completed_loan_id\n    from\n    (\n        select\n            {{USERID}} as user_id\n            ,{{PVDATE}} as epoch_millis\n    ) sc\n    left join user_loan ul on ul.user_id = sc.user_id and ul.status in ('COMPLETED') and unix_timestamp(ul.updated_at) <= epoch_millis\n    group by 1,2\n) sc\nleft join\n(\n    select distinct cibil.user_id\n            ,cibil.cibil_id as cibil_metadata_id\n            ,cibil.cibil_pull_dt as cibil_pull_dt\n            ,ucr.score as cibil_score \n            ,ucr.id as cibil_report_id \n            from\n        ( select\n                user_id\n                ,max(metadata_id) as cibil_id\n                ,max(fetched_at) as cibil_pull_dt \n          from user_cibil_report \n            where 1=1\n                and user_id={{USERID}}\n                and unix_timestamp(timestampadd(minute,0,fetched_at))*1000 <= {{PVDATE}}\n            group by 1\n        ) cibil \n         left join user_cibil_report ucr on cibil.cibil_id=ucr.metadata_id\n) cv on cv.user_id=sc.user_id\n\n\n",
        'DuckDB Query':"WITH max_metadata_id AS (\nSELECT \n        MAX(metadata_id) AS metadata_id,\n        MAX(fetched_at) AS fetched_at\n    FROM user_cibil_report__v1\n    WHERE EPOCH_MS(fetched_at) <= {{pv_date}} \n),\n\ncibil_data AS (\n    SELECT\n        user_id,\n        score AS cibil_score\n    FROM user_cibil_report__v1\n    WHERE metadata_id = (SELECT metadata_id FROM max_metadata_id)\n),\n\nlatest_completed_loan_id_tbl AS (\n    SELECT\n        c.*,\n        MAX(ul.id) AS latest_completed_loan_id\n    FROM cibil_data c LEFT JOIN user_loan__v1 ul\n    USING(user_id)\n    GROUP BY 1,2\n)\n\nSELECT \n\n    CASE WHEN cibil_score IS NULL THEN -9999\n          WHEN latest_completed_loan_id IS NOT NULL THEN (CASE WHEN cibil_score >=300 AND cibil_score < 620 THEN 1 ELSE 0 END)\n          WHEN latest_completed_loan_id IS NULL THEN (CASE WHEN cibil_score >=300 AND cibil_score < 680 THEN 1 ELSE 0 END)\n          ELSE 0 END AS VALUE\n    ,coalesce(cibil_score, -9999) AS cibil_score\nFROM latest_completed_loan_id_tbl\n\n"
    },

    {
        'MySQL Query':"select \nbase.user_id\n,base.epoch_millis\n,case when apa.pa_user_id is not null and lid.loan_index_at_uw = apa.loan_index then 1\n      when pa.pa_user_id is not null and date(ld.latest_disbursal_date) <= date((pa.base_select_date + interval '2' day)) then 1\n      else 0 end as pa_flag\n,coalesce(apa.amount_offered,coalesce(pa.amount_offered,-1)) as prev_amount_offered\n,coalesce(apa.multiplier_1,coalesce(pa.multiplier_1,-1)) as multiplier_1\n,coalesce(apa.multiplier_2,coalesce(pa.multiplier_2,-1)) as multiplier_2\n,coalesce(apa.multiplier_3,coalesce(pa.multiplier_3,-1)) as multiplier_3\n,coalesce(apa.multiplier_4,coalesce(pa.multiplier_4,-1)) as multiplier_4\n,0 as value\nfrom \n(\n    select \n    {{USERID}} as user_id\n    ,{{PVDATE}} as epoch_millis\n) base\nleft join \n(\n    select \n    user_id as pa_user_id\n    ,max_unlock_amount as amount_offered\n    ,factor1 as multiplier_1\n    ,factor2 as multiplier_2\n    ,factor3 as multiplier_3\n    ,factor4 as multiplier_4\n    ,loan_index\n    from \n    user_pre_approved_loan_offers_details\n    where 1=1\n          and user_id = {{USERID}}\n          and repeat_user_flag = 1\n          and unix_timestamp(expiry_date)*1000 > {{PVDATE}}\n) apa on apa.pa_user_id=base.user_id\nleft join \n(\n    select \n    user_id as pa_user_id \n    ,amount_offered\n    ,date(base_select_date) as base_select_date\n    ,multiplier_1\n    ,multiplier_2\n    ,multiplier_3\n    ,multiplier_4\n    from \n    user_pre_approved_base\n    where 1=1\n          and user_id = {{USERID}}\n          and customer_type = 'REPEAT'\n          and base_select_date = (select max(base_select_date) from user_pre_approved_base where customer_type = 'REPEAT')\n) pa on pa.pa_user_id = base.user_id\nleft join\n(\n    select\n    base.user_id\n    ,coalesce(date(max(ul.disbursed_at)),date(from_unixtime({{PVDATE}}\/1000.0))) as latest_disbursal_date\n    from \n    (\n        select \n        {{USERID}} as user_id\n        ,{{PVDATE}} as epoch_millis\n    ) base\n    left join user_loan ul on ul.user_id = base.user_id and ul.status in ('DISBURSED','COMPLETED')\n    group by 1\n) ld on ld.user_id = base.user_id\nleft join \n(\n    select\n    max_lid.user_id\n    ,max_lid.latest_loan_id as previous_loan_id\n    ,ulm.loan_index as loan_index_at_uw\n    ,lp.amount as previous_amount_offered\n    from \n    (\n        select\n        ul.user_id\n        ,max(ul.id) as latest_loan_id\n        from \n        user_loan ul\n        where 1=1\n              and ul.user_id = {{USERID}}\n              and ul.status in ('COMPLETED','DISBURSED')\n              and unix_timestamp(ul.applied_at)*1000 <= {{PVDATE}}\n        group by 1\n    ) max_lid\n    inner join user_loan_metadata ulm on ulm.user_loan_id = max_lid.latest_loan_id\n    inner join loan_product lp on lp.id = ulm.higher_lp_id\n) lid on lid.user_id = base.user_id",
        'DuckDB Query':"WITH base AS (\n    SELECT \n        {{user_id}} AS user_id,\n        {{pv_date}} AS epoch_millis\n),\napa AS (\n    SELECT \n        user_id AS pa_user_id,\n        max_unlock_amount AS amount_offered,\n        factor1 AS multiplier_1,\n        factor2 AS multiplier_2,\n        factor3 AS multiplier_3,\n        factor4 AS multiplier_4,\n        loan_index\n    FROM \n        user_pre_approved_loan_offers_details__v1\n    WHERE \n        repeat_user_flag = 1\n        AND expiry_date > epoch_ms({{pv_date}})\n),\npa AS (\n    SELECT \n        user_id AS pa_user_id, \n        amount_offered,\n        CAST(base_select_date AS DATE) AS base_select_date,\n        multiplier_1,\n        multiplier_2,\n        multiplier_3,\n        multiplier_4\n    FROM \n        user_pre_approved_base__v1\n    WHERE \n        customer_type = 'REPEAT'\n        AND base_select_date = (\n            SELECT MAX(base_select_date) \n            FROM user_pre_approved_base__v1 \n            WHERE customer_type = 'REPEAT'\n        )\n),\nld AS (\n    SELECT \n        base.user_id,\n        COALESCE(CAST(MAX(ul.disbursed_at) AS DATE), CAST(epoch_ms({{pv_date}}) AS DATE)) AS latest_disbursal_date\n    FROM base\n    LEFT JOIN user_loan__v1 ul \n        ON ul.user_id = base.user_id \n        AND ul.status IN ('DISBURSED', 'COMPLETED')\n    GROUP BY base.user_id\n),\nlid AS (\nSELECT \n        max_lid.user_id,\n        max_lid.latest_loan_id AS previous_loan_id,\n        ulm.loan_index AS loan_index_at_uw,\n        lp.lp_amount AS previous_amount_offered\n    FROM (\n        SELECT \n            ul.user_id,\n            MAX(ul.id) AS latest_loan_id\n        FROM \n            user_loan__v1 ul\n        WHERE \n            ul.status IN ('COMPLETED', 'DISBURSED')\n            AND ul.applied_at <= epoch_ms({{pv_date}})\n        GROUP BY ul.user_id\n    ) max_lid\n    INNER JOIN user_loan_metadata__v1 ulm \n        ON ulm.user_loan_id = max_lid.latest_loan_id\n    INNER JOIN loan_product__v1 lp \n        ON lp.prev_user_loan_ids = ulm.higher_lp_id\n)\nSELECT \n    base.user_id,\n    base.epoch_millis,\n    CASE \n        WHEN apa.pa_user_id IS NOT NULL AND lid.loan_index_at_uw = apa.loan_index THEN 1\n        WHEN pa.pa_user_id IS NOT NULL AND CAST(ld.latest_disbursal_date AS DATE) <= CAST((pa.base_select_date + INTERVAL '2 day') AS DATE) THEN 1\n        ELSE 0 \n    END AS pa_flag,\n    COALESCE(apa.amount_offered, COALESCE(pa.amount_offered, -1)) AS prev_amount_offered,\n    COALESCE(apa.multiplier_1, COALESCE(pa.multiplier_1, -1)) AS multiplier_1,\n    COALESCE(apa.multiplier_2, COALESCE(pa.multiplier_2, -1)) AS multiplier_2,\n    COALESCE(apa.multiplier_3, COALESCE(pa.multiplier_3, -1)) AS multiplier_3,\n    COALESCE(apa.multiplier_4, COALESCE(pa.multiplier_4, -1)) AS multiplier_4,\n    0 AS value\nFROM base\nLEFT JOIN apa ON apa.pa_user_id = base.user_id\nLEFT JOIN pa ON pa.pa_user_id = base.user_id\nLEFT JOIN ld ON ld.user_id = base.user_id\nLEFT JOIN lid ON lid.user_id = base.user_id\n\n\n"
    },
    {
        'MySQL Query':"SELECT  \nsc.user_id\n,sc.epoch_millis\n,'collection_agent_pincode' as feature\n,coalesce(s.agent_pincodes, -9999) as value\nFROM\n    (\n    select\n        {{USERID}} as user_id\n        ,{{PVDATE}} as epoch_millis\n    ) sc\n   left join\n   ( select user_id,workplace_pincode,pc.pincode\n            ,case when pincode is null or workplace_pincode is null then -9999\n                 when pincode <> workplace_pincode then 1\n                 else 0 end as agent_pincodes\n                 from \n      (SELECT user_id,\n                 workplace_pincode\n          FROM profile\n          WHERE user_id = {{USERID}}\n            AND created_at <= from_unixtime({{PVDATE}}\/1000) \n        ) t\n        left join field_collection_agent_pincodes pc on pc.pincode=t.workplace_pincode\n    )s\n        on s.user_id=sc.user_id\n      \n      ",
        'DuckDB Query':"with cibil_data as (\n    select\n        user_id,\n        max(metadata_id) as cibil_id,\n        max_by(pan, metadata_id) as pan\n    from user_cibil_report__v1\n    where\n        report_type = 'SOFT_PULLED'\n        and epoch_ms(fetched_at) <= {{pv_date}}\n    group by 1\n)\n\nselect\n    case \n        when c.cibil_id is null then 0\n        when p.pan is null then 0\n        when cast(upper(trim(c.pan)) as binary) <> cast(upper(trim(p.pan)) as binary) then 1 \n        else 0 \n    end as value\nfrom profile__v1 p left join cibil_data c\nusing(user_id)\n\n\n"
    }
]